import { z } from "zod";
import { ChatterboxService } from "../core/chatterbox.service";
import fs from "fs";
import path from "path";
import os from "os";
import { logger } from "../utils/logger";

const TEMP_AUDIO_DIR = path.join(os.tmpdir(), "local-voice-mcp");

// Create temp directory if it doesn't exist
if (!fs.existsSync(TEMP_AUDIO_DIR)) {
  fs.mkdirSync(TEMP_AUDIO_DIR, { recursive: true });
}

/**
 * Helper to create a standardized error response object
 */
function createErrorResponse(
  errorType: string,
  message: string,
  details?: Record<string, any>
) {
  return {
    content: [
      {
        type: "text" as const,
        text: JSON.stringify(
          {
            success: false,
            error: errorType,
            message,
            timestamp: new Date().toISOString(),
            ...details,
          },
          null,
          2
        ),
      },
    ],
    isError: true,
  };
}

/**
 * TTS Tool Implementation for MCP
 */
export class TTSTools {
  private chatterbox: ChatterboxService;

  constructor() {
    this.chatterbox = new ChatterboxService();
  }

  /**
   * Ensure the TTS service is ready
   */
  async ensureReady(): Promise<void> {
    await this.chatterbox.ensureReady();
  }

  /**
   * Text-to-Speech synthesis tool
   * Converts text to speech and returns the audio file path
   */
  async synthesizeText(params: {
    text: string;
    referenceAudio?: string;
    exaggeration?: number;
    cfg_weight?: number;
  }) {
    const {
      text,
      referenceAudio: rawReferenceAudioPath, // Use a different name to avoid confusion
      exaggeration = 0.2,
      cfg_weight = 1.0,
    } = params;

    // Validate text (existing logic is fine)
    if (!text || typeof text !== "string" || text.trim().length === 0) {
      return createErrorResponse(
        "Invalid input",
        "Text parameter is required and cannot be empty"
      );
    }

    let maxCharacters = parseInt(
      process.env.CHATTERBOX_MAX_CHARACTERS || "2000",
      10
    );
    if (isNaN(maxCharacters) || maxCharacters <= 0) {
      // Added robustness for maxCharacters
      logger.warn(`Invalid CHATTERBOX_MAX_CHARACTERS, defaulting to 2000.`);
      maxCharacters = 2000;
    }
    if (text && text.length > maxCharacters) {
      return createErrorResponse(
        "Text too long",
        `Text exceeds maximum character limit of ${maxCharacters} characters.`,
        {
          maxCharacters,
          currentLength: text.length,
          sanitizedInput:
            typeof text === "string"
              ? text.replace(/[\r\n\t]/g, " ").substring(0, 100)
              : "",
        }
      );
    }

    let resolvedReferenceAudioPath: string | undefined;
    if (rawReferenceAudioPath) {
      try {
        // Use the ChatterboxService's validateReferenceAudioPath method directly
        // This allows access to any audio file on the user's system
        resolvedReferenceAudioPath = this.chatterbox.validateReferenceAudioPath(
          rawReferenceAudioPath
        );
      } catch (error) {
        const message =
          error instanceof Error ? error.message : "Unknown error";
        return createErrorResponse(
          "Invalid Reference Audio",
          `Reference audio validation failed: ${message}`,
          {
            providedPath: rawReferenceAudioPath,
            supportedFormats: [".wav", ".mp3", ".flac", ".ogg", ".m4a", ".aac"],
          }
        );
      }
    }

    try {
      const audioPath = await this.chatterbox.synthesize(text, {
        // Pass the *resolved and validated* path to the core service
        referenceAudio: resolvedReferenceAudioPath,
        exaggeration,
        cfg_weight,
      });

      // Validate audio path is within TEMP_AUDIO_DIR (security check for output)
      const resolvedOutputPath = path.resolve(audioPath);
      const normalizedTempDir = path.normalize(TEMP_AUDIO_DIR) + path.sep;
      if (!resolvedOutputPath.startsWith(normalizedTempDir)) {
        logger.error(
          `Generated audio path "${resolvedOutputPath}" is outside the allowed temporary directory "${normalizedTempDir}". This is a critical security concern.`
        );
        throw new Error(
          "Invalid audio path generated by synthesis service: Path is outside the allowed temporary directory."
        );
      }

      return {
        content: [
          {
            type: "text" as const,
            text: JSON.stringify(
              {
                success: true,
                message: "Speech synthesis completed successfully",
                audioFile: audioPath, // Return the path as generated by chatterbox (likely already in TEMP_AUDIO_DIR)
                textLength: text.length,
                audioFormat: "wav", // This might need to be dynamic based on chatterbox output
                options: { exaggeration, cfg_weight },
                generatedAt: new Date().toISOString(),
              },
              null,
              2
            ),
          },
        ],
      };
    } catch (error) {
      logger.error("TTS synthesis error:", error);
      return createErrorResponse(
        "TTS synthesis failed",
        error instanceof Error ? error.message : "Unknown error"
      );
    }
  }

  /**
   * Get TTS service status
   */
  async getStatus() {
    try {
      await this.chatterbox.ensureReady();
      return {
        content: [
          {
            type: "text" as const,
            text: JSON.stringify(
              {
                success: true,
                status: "operational",
                message: "TTS service is ready and operational",
                timestamp: new Date().toISOString(),
                service: {
                  name: "Chatterbox TTS",
                  version: "0.1.0",
                  capabilities: [
                    "text-to-speech synthesis",
                    "voice cloning with reference audio",
                    "prosody controls",
                  ],
                },
              },
              null,
              2
            ),
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text" as const,
            text: JSON.stringify(
              {
                success: false,
                status: "error",
                message: "TTS service is not ready",
                error: error instanceof Error ? error.message : "Unknown error",
                timestamp: new Date().toISOString(),
              },
              null,
              2
            ),
          },
        ],
        isError: true,
      };
    }
  }

  /**
   * Safely delete an audio file if requested
   * @param filePath - The resolved file path to delete
   * @param deleteAfterPlay - Whether deletion was requested
   * @param originalFileName - The original filename for logging
   * @returns Object with deletion status and message
   */
  private deleteAudioFileIfRequested(
    filePath: string,
    deleteAfterPlay: boolean,
    originalFileName: string
  ): { deleted: boolean; deleteMessage?: string } {
    if (!deleteAfterPlay) {
      return { deleted: false };
    }

    try {
      // Security check: Ensure file is still in temp directory
      const normalizedTempDir = path.normalize(TEMP_AUDIO_DIR);
      if (
        !filePath.startsWith(normalizedTempDir + path.sep) &&
        filePath !== normalizedTempDir
      ) {
        logger.warn(
          `Deletion skipped: File "${filePath}" is outside temp directory`
        );
        return {
          deleted: false,
          deleteMessage: "Deletion skipped: File outside temp directory",
        };
      }

      // Check if file exists before attempting deletion
      if (!fs.existsSync(filePath)) {
        logger.info(`File "${originalFileName}" already deleted or not found`);
        return {
          deleted: false,
          deleteMessage: "File already deleted or not found",
        };
      }

      // Attempt deletion
      fs.unlinkSync(filePath);
      logger.info(`Successfully deleted audio file: ${originalFileName}`);
      return {
        deleted: true,
        deleteMessage: `Successfully deleted audio file: ${originalFileName}`,
      };
    } catch (error) {
      const errorMessage = `Failed to delete audio file "${originalFileName}": ${
        error instanceof Error ? error.message : String(error)
      }`;
      logger.error(errorMessage);
      return {
        deleted: false,
        deleteMessage: errorMessage,
      };
    }
  }

  /**
   * Play an audio file using the system's default audio player
   */
  async playAudio(params: {
    audioFile: string;
    volume?: number;
    deleteAfterPlay?: boolean;
  }): Promise<{
    content: Array<{
      type: "text";
      text: string;
    }>;
    isError?: boolean;
  }> {
    const {
      audioFile: rawAudioFile,
      volume: rawVolume,
      deleteAfterPlay = false,
    } = params; // Rename to distinguish from resolved path

    if (!rawAudioFile || rawAudioFile.trim().length === 0) {
      return createErrorResponse(
        "Invalid input",
        "Audio file path is required and cannot be empty"
      );
    }

    // Validate and resolve volume parameter
    let volume: number;
    if (rawVolume !== undefined) {
      // Validate volume parameter
      if (
        typeof rawVolume !== "number" ||
        !Number.isInteger(rawVolume) ||
        rawVolume < 0 ||
        rawVolume > 100
      ) {
        return createErrorResponse(
          "Invalid Volume",
          `Volume must be an integer between 0 and 100. Provided: ${rawVolume}`
        );
      }
      volume = rawVolume;
    } else {
      // Use environment variable or default
      const envVolume = process.env.CHATTERBOX_PLAYBACK_VOLUME;
      if (envVolume) {
        const parsedVolume = parseInt(envVolume, 10);
        if (isNaN(parsedVolume) || parsedVolume < 0 || parsedVolume > 100) {
          logger.warn(
            `Invalid CHATTERBOX_PLAYBACK_VOLUME: ${envVolume}. Using default volume 50.`
          );
          volume = 50;
        } else {
          volume = parsedVolume;
        }
      } else {
        volume = 50; // Default volume
      }
    }

    let resolvedPathToPlay: string;
    try {
      // 1. Resolve the path
      resolvedPathToPlay = path.resolve(rawAudioFile);
    } catch (e) {
      return createErrorResponse(
        "Invalid Path",
        `Audio file path could not be resolved. Original: "${rawAudioFile}"`
      );
    }

    // 2. SECURITY CHECK: Ensure the file to be played is within TEMP_AUDIO_DIR
    // This is a crucial security boundary for the `playAudio` function.
    const normalizedTempDir = path.normalize(TEMP_AUDIO_DIR);
    if (
      !resolvedPathToPlay.startsWith(normalizedTempDir + path.sep) &&
      resolvedPathToPlay !== normalizedTempDir
    ) {
      // Check if it's exactly the temp dir, or starts with temp dir + separator
      return createErrorResponse(
        "Access Denied",
        "Audio file must be in the application's temporary directory for playback.",
        {
          allowedDirectory: TEMP_AUDIO_DIR,
          requestedFile: rawAudioFile,
          resolvedFile: resolvedPathToPlay,
        }
      );
    }

    // 3. Check existence and type (it should have been created by synthesizeText or similar)
    if (!fs.existsSync(resolvedPathToPlay)) {
      return createErrorResponse(
        "File Not Found",
        `Audio file does not exist: "${rawAudioFile}" (resolved to "${resolvedPathToPlay}")`
      );
    }
    try {
      if (!fs.statSync(resolvedPathToPlay).isFile()) {
        return createErrorResponse(
          "Not a File",
          `Audio path is not a file: "${rawAudioFile}" (resolved to "${resolvedPathToPlay}")`
        );
      }
    } catch (e) {
      return createErrorResponse(
        "File Access Error",
        `Cannot access audio file: "${rawAudioFile}". Error: ${
          e instanceof Error ? e.message : String(e)
        }`
      );
    }

    // 4. Validate file extension
    const ext = path.extname(resolvedPathToPlay).toLowerCase();
    if (![".wav", ".mp3"].includes(ext)) {
      return createErrorResponse(
        "Unsupported Format",
        `Unsupported audio format: "${ext}". Supported: .wav, .mp3. File: "${rawAudioFile}"`
      );
    }

    try {
      // Play the audio file using system command
      // IMPORTANT: Command Injection Mitigation for `spawn`
      // By passing arguments as an array to `spawn`, you avoid direct shell interpretation
      // of the arguments, which is the primary defense against command injection.
      // The `resolvedPathToPlay` has been validated to be within TEMP_AUDIO_DIR.
      const { spawn } = require("child_process");
      let command: string;
      let args: string[];

      const fileArg = resolvedPathToPlay; // Use the fully resolved, validated path

      // Try ffplay first for cross-platform consistency and volume control
      // ffplay is part of ffmpeg and widely available
      const tryFFPlay = async (): Promise<{
        command: string;
        args: string[];
      } | null> => {
        return new Promise((resolve) => {
          const testProcess = spawn("ffplay", ["-version"], {
            stdio: "ignore",
          });
          testProcess.on("close", (code: number | null) => {
            if (code === 0) {
              // ffplay is available, use it with volume control
              resolve({
                command: "ffplay",
                args: [
                  "-volume",
                  volume.toString(),
                  "-nodisp",
                  "-autoexit",
                  fileArg,
                ],
              });
            } else {
              resolve(null);
            }
          });
          testProcess.on("error", () => {
            resolve(null);
          });
        });
      };

      // Try ffplay first
      const ffplayResult = await tryFFPlay();
      if (ffplayResult) {
        command = ffplayResult.command;
        args = ffplayResult.args;
      } else {
        // Fallback to platform-specific commands with volume support where possible
        if (process.platform === "darwin") {
          command = "afplay";
          // afplay volume: -v flag, range 0.0 to 1.0+
          const volumeFloat = volume / 100;
          args = ["-v", volumeFloat.toString(), fileArg];
        } else if (process.platform === "win32") {
          command = "powershell";
          // For PowerShell, ensure paths with spaces are handled and add volume control
          const volumeFloat = volume / 100;
          const psScript = `
            Add-Type -AssemblyName PresentationCore;
            $player = New-Object System.Windows.Media.MediaPlayer;
            $player.Volume = ${volumeFloat};
            $player.Open([System.Uri]::new('${fileArg.replace(/'/g, "''")}'));
            $player.Play();
            while ($player.Source -ne $null -and $player.Position -lt $player.NaturalDuration) { Start-Sleep -Milliseconds 200 };
          `;
          args = [
            "-NoProfile",
            "-NonInteractive",
            "-ExecutionPolicy",
            "Bypass",
            "-Command",
            psScript,
          ];
        } else {
          // Linux fallback - limited volume control
          if (ext === ".mp3") {
            command = "mpg123";
            // mpg123 uses --gain for volume in dB. Convert percentage to rough dB.
            // 50% = 0dB, 100% = +6dB, 0% = -20dB (approximate)
            const gainDb = volume === 0 ? -20 : (volume - 50) * 0.12;
            args = ["-q", "--gain", gainDb.toFixed(1), fileArg];
          } else {
            // .wav - aplay doesn't have volume control, use as-is
            command = "aplay";
            args = ["-q", fileArg];
            logger.warn(
              `Volume control not available for aplay. Playing at system volume. Requested volume: ${volume}%`
            );
          }
        }
      }

      return new Promise((resolve) => {
        const PLAYBACK_TIMEOUT = 30000; // 30 seconds
        let timeoutId: NodeJS.Timeout;

        logger.info(`Executing playback: ${command} ${args.join(" ")}`);
        const player = spawn(command, args);

        timeoutId = setTimeout(() => {
          player.kill("SIGTERM");
          const deletionResult = this.deleteAudioFileIfRequested(
            resolvedPathToPlay,
            deleteAfterPlay,
            rawAudioFile
          );
          resolve(
            createErrorResponse(
              "Playback Timeout",
              `Audio playback timed out after ${
                PLAYBACK_TIMEOUT / 1000
              } seconds`,
              deletionResult.deleted
                ? {
                    fileDeleted: true,
                    deleteMessage: deletionResult.deleteMessage,
                  }
                : undefined
            )
          );
        }, PLAYBACK_TIMEOUT);

        let stderrOutput = "";
        if (player.stderr) {
          player.stderr.on("data", (data: any) => {
            stderrOutput += data.toString();
          });
        }

        player.on("close", (code: number) => {
          clearTimeout(timeoutId);
          if (code === 0) {
            const deletionResult = this.deleteAudioFileIfRequested(
              resolvedPathToPlay,
              deleteAfterPlay,
              rawAudioFile
            );
            resolve({
              content: [
                {
                  type: "text" as const,
                  text: JSON.stringify(
                    {
                      success: true,
                      message: `Successfully played audio file: ${rawAudioFile}`,
                      audioFile: rawAudioFile,
                      volume: volume,
                      platform: process.platform,
                      command: `${command} ${args.join(" ")}`,
                      timestamp: new Date().toISOString(),
                      fileDeleted: deletionResult.deleted,
                      ...(deletionResult.deleteMessage && {
                        deleteMessage: deletionResult.deleteMessage,
                      }),
                    },
                    null,
                    2
                  ),
                },
              ],
            });
          } else {
            logger.error(
              `Playback failed for "${fileArg}". Command: ${command} ${args.join(
                " "
              )}. Exit code: ${code}. Stderr: ${stderrOutput}`
            );
            const deletionResult = this.deleteAudioFileIfRequested(
              resolvedPathToPlay,
              deleteAfterPlay,
              rawAudioFile
            );
            resolve(
              createErrorResponse(
                "Playback Failed",
                `Audio playback command failed with exit code: ${code}. File: "${rawAudioFile}". Stderr: ${stderrOutput.substring(
                  0,
                  200
                )}`,
                deletionResult.deleted
                  ? {
                      fileDeleted: true,
                      deleteMessage: deletionResult.deleteMessage,
                    }
                  : undefined
              )
            );
          }
        });

        player.on("error", (err: Error) => {
          clearTimeout(timeoutId);
          logger.error(
            `Failed to start playback for "${fileArg}". Command: ${command}. Error: ${err.message}`
          );
          const deletionResult = this.deleteAudioFileIfRequested(
            resolvedPathToPlay,
            deleteAfterPlay,
            rawAudioFile
          );
          resolve(
            createErrorResponse(
              "Command Execution Failed",
              `Failed to start audio player "${command}". Error: ${err.message}. Is the player installed and in PATH?`,
              deletionResult.deleted
                ? {
                    fileDeleted: true,
                    deleteMessage: deletionResult.deleteMessage,
                  }
                : undefined
            )
          );
        });
      });
    } catch (error) {
      logger.error("Audio playback error:", error);
      return createErrorResponse(
        "Playback error",
        error instanceof Error ? error.message : "Unknown error"
      );
    }
  }
}

/**
 * Execute tool and handle errors
 * @param toolName - Name of the tool to execute
 * @param args - Arguments for the tool
 * @param ttsTools - TTSTools instance
 * @returns Tool execution result
 */
export async function executeToolAndHandleErrors(
  toolName: string,
  args: any,
  ttsTools: TTSTools
): Promise<any> {
  try {
    switch (toolName) {
      case "synthesize_text":
        return await ttsTools.synthesizeText(args);
      case "play_audio":
        return await ttsTools.playAudio(args);
      case "tts_status":
        return await ttsTools.getStatus();
      default:
        throw new Error(`Unknown tool: ${toolName}`);
    }
  } catch (error) {
    // Return error in the expected format
    return {
      content: [
        {
          type: "text" as const,
          text: JSON.stringify(
            {
              success: false,
              error: "Tool execution failed",
              message: error instanceof Error ? error.message : "Unknown error",
              tool: toolName,
              timestamp: new Date().toISOString(),
            },
            null,
            2
          ),
        },
      ],
      isError: true,
    };
  }
}

// Tool type definition
export interface Tool {
  name: string;
  description: string;
  inputSchema: {
    type: "object";
    properties: Record<string, any>;
    required?: string[];
  };
}

/**
 * Synthesize Text Tool
 * @param {object} args - A JSON object containing the arguments
 * @see {synthesizeTextToolExecutor}
 */
const synthesizeTextTool: Tool = {
  name: "synthesize_text",
  description:
    "Convert text to speech with optional voice cloning using reference audio. Supports prosody controls for exaggeration and configuration weight.",
  inputSchema: {
    type: "object",
    properties: {
      text: {
        type: "string",
        description:
          "The text to convert to speech. Must be non-empty and under the character limit.",
      },
      referenceAudio: {
        type: "string",
        description: "Optional path to reference audio file for voice cloning.",
      },
      exaggeration: {
        type: "number",
        description:
          "Voice style exaggeration level (0.0 to 2.0, default: 0.2).",
        minimum: 0,
        maximum: 2,
      },
      cfg_weight: {
        type: "number",
        description:
          "Configuration weight for TTS model (0.0 to 5.0, default: 1.0).",
        minimum: 0,
        maximum: 5,
      },
    },
    required: ["text"],
  },
};

/**
 * Play Audio Tool
 * @param {object} args - A JSON object containing the arguments
 * @see {playAudioToolExecutor}
 */
const playAudioTool: Tool = {
  name: "play_audio",
  description:
    "Play an audio file using the system's default audio player with optional volume control and file cleanup. Supports WAV and MP3 formats. Files must be in the temporary directory for security.",
  inputSchema: {
    type: "object",
    properties: {
      audioFile: {
        type: "string",
        description:
          "Path to the audio file to play. Must be a .wav or .mp3 file in the temporary directory.",
      },
      volume: {
        type: "number",
        description:
          "Playback volume as a percentage (0-100). If not specified, uses CHATTERBOX_PLAYBACK_VOLUME environment variable or default of 50.",
        minimum: 0,
        maximum: 100,
      },
      deleteAfterPlay: {
        type: "boolean",
        description:
          "Whether to delete the audio file after playback completes (success or failure). Default: false. Useful for cleaning up temporary audio files.",
      },
    },
    required: ["audioFile"],
  },
};

/**
 * TTS Status Tool
 * @param {object} args - A JSON object containing the arguments
 * @see {ttsStatusToolExecutor}
 */
const ttsStatusTool: Tool = {
  name: "tts_status",
  description:
    "Get the current status of the TTS service, including operational state and capabilities.",
  inputSchema: {
    type: "object",
    properties: {},
    required: [],
  },
};

// Export all tools as an array
export const ALL_TOOLS: Tool[] = [
  synthesizeTextTool,
  playAudioTool,
  ttsStatusTool,
];

// Schema definitions for validation (keeping for backward compatibility)
export const TTSToolSchemas = {
  synthesizeText: {
    text: z.string().min(1, "Text cannot be empty"),
    referenceAudio: z.string().optional(),
    exaggeration: z.number().min(0).max(2).optional(),
    cfg_weight: z.number().min(0).max(5).optional(),
  },
  playAudio: {
    audioFile: z.string().min(1, "Audio file path cannot be empty"),
    volume: z.number().min(0).max(100).optional(),
    deleteAfterPlay: z.boolean().optional(),
  },
  getStatus: {},
};
